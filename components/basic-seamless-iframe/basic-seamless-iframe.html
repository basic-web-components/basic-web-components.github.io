<!--
This component frames a page, potentially on a separate domain, and then
automatically communicates with a corresponding element on a framed page to
enable common cross-frame communication scenarios. For example, this component
can automatically adjust its height to match that of the framed page. (This
replicates the intent of the standard HTML "seamless" iframe attribute, which is
unfortunately implemented poorly on most browsers.)

This component can also be used to let you pass content back and forth between
the framed page and the outer page.

Such scenarios are normally blocked whenever an iframe hosts a page on a
different domain. Various web sources recommend that a frame and its contained
page communicate by means of window.postMessage(), but this is somewhat
cumbersome to set up. This component and its companion, basic-framed-content,
transparently set up and handle that postMessage-based communication for you.

If the framed page contains a basic-framed-content element, then:

1. The outer basic-seamless-iframe can set and inspect the content of the
   inner basic-framed-content element.
2. The outer basic-seamless-iframe can adjust its height to exactly contain the
   inner basic-framed-content element.

@element basic-seamless-iframe
@demo ../packages/sample/basic-seamless-iframe/index.html
-->

<!--
TODO: Extend an HTML iframe element directly?
TODO: Give contained pages on the same domain more direct ways to cooperatively
communicate with this element.
-->

<link rel="import" href="../polymer/polymer.html">

<polymer-element name="basic-seamless-iframe" attributes="autoSize src">

<template>

  <style>
  :host {
    display: block;
  }

  #iframe {
    border: none;
    display: block;
    height: 100%;
    width: 100%;
  }
  </style>

  <iframe id="iframe" src="{{src}}" scrollbars="no"></iframe>

</template>

<script>
Polymer( "basic-seamless-iframe", {

  /**
   * Fired when a basic-framed-content element within the framed page has had
   * its content change.
   *
   * @event framedContentChanged
   * @param Object detail The new content of the basic-framed-content element.
   */

  /**
   * If true, the element will automatically adjust its height to match that of
   * a contained basic-framed-content element on the framed page.
   * 
   * @attribute autoSize
   * @type boolean
   * @default true
   */
  autoSize: true,

  autoSizeChanged: function() {
    if ( this.autoSize ) {
      this._postMessageToFrame( "requestHeight" );      
    }
  },

  ready: function() {
    window.addEventListener( "resize", function() {
      if ( this.autoSize && this.clientWidth !== this._clientWidth ) {
        // Ping framed content for its new -- potentially changed -- height.
        this._postMessageToFrame( "requestHeight" );
        this._clientWidth = this.clientWidth;
      }
    }.bind( this ));

    // Raise our own load event when the frame loads.
    this.$.iframe.addEventListener( "load", function() {
      this.dispatchEvent( new CustomEvent( "load" ));
    }.bind( this ));

    // Listen for messages posted by the framed page.
    window.addEventListener( "message", function( event ) {
      // For security reasons, only handle messages with the same origin as the
      // framed page.
      if  ( event.origin !== this._frameOrigin ) {
        return;
      }
      // We also check that the message (ostensibly) comes from the framed page.
      // This can be spoofed, but isn't intended as a security measure. Rather,
      // it's just a way that this component can indentify which messages are
      // meant for it.
      if ( !event.data || event.data.source !== this.$.iframe.src ) {
        return;
      }
      switch ( event.data && event.data.message ) {

        case "framedContentResponse":
          this._framedContentChanged( event.data.detail );

        case "framedHeightResponse":
          this._framedHeightChanged( event.data.detail );

        case "framedPolymerReady":
          this._frameReady = true;
          this._updateFramedContent();

      }
    }.bind( this ), false );
  },

  srcChanged: function() {
    // Extract the origin from the src using an anchor tag as a parser.
    var a = document.createElement( "a" );
    a.href = this.src;
    this._frameOrigin = a.origin;
  },

  /**
   * Pass the indicated content to the basic-framed-content element within the
   * framed page.
   *
   * @method setFramedContent
   * @param content The content to pass to the basic-framed-content element.
   */
  setFramedContent: function( content ) {
    this._pendingContent = content;
    this._updateFramedContent();
  },

  // Track the last known width of this element.
  _clientWidth: null,

  _framedContentChanged: function( framedContent ) {
    var event = new CustomEvent( "framedContentChanged", {
      detail: framedContent
    });
    this.dispatchEvent( event );
  },

  _framedHeightChanged: function( framedHeight ) {
    if ( this.autoSize ) {
      this.style.height = framedHeight + "px";
    }
  },

  _frameReady: false,

  // Content we want to write to the framed page when it's ready for it.
  _pendingContent: null,

  _updateFramedContent: function() {
    if ( this._frameReady && this._pendingContent != null ) {
      this._postMessageToFrame( "setContent", this._pendingContent );
      this._pendingContent = null;
    }
  },

  _postMessageToFrame: function( message, detail ) {
    var payload = {
      message: message
    };
    if ( detail ) {
      payload.detail = detail;
    }
    this.$.iframe.contentWindow.postMessage( payload, this._frameOrigin );
  }

});
</script>

</polymer-element>
